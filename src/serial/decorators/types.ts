import { ReviverCtx, Serialized } from '..';
import Serializable from './serializable';

export const SerialPropertyMetadataKey = 'serialPropertyMetadata';

/**
 * The interface to fulfill to qualify as a Value Object.
 */
export interface ValueObject {
	/**
	 * Determins the equality of objects when serializing and deserializing objects.
	 *
	 * True if 'this' and the 'other' object which is being serialized or deserialized are equal.
	 * It is critical for the optimization of these processes.
	 */
	equals(other: unknown): boolean;

	/**
	 * Computes and returns the hashed identity for this Serializable.
	 *
	 * The `hashCode` of a Serializable is used to determine potential equality,
	 * and is used when serializing and deserializaing.
	 *
	 *
	 * Note: hashCode() MUST return a Uint32 number. The easiest way to
	 * guarantee this is to return `myHash | 0` from a custom implementation.
	 *
	 * If two values have the same `hashCode`, they are [not guaranteed
	 * to be equal][Hash Collision]. If two values have different `hashCode`s,
	 * they must not be equal.
	 *
	 * [Hash Collision]: https://en.wikipedia.org/wiki/Collision_(computer_science)
	 */
	hashCode(): number;
}

export interface Revivable<S extends Serialized = Serialized> {
	revive?(serialObj: S, ctx: ReviverCtx): void;
	afterPropertyRevived?(prop: string, value: any): any;
	afterRevived?(): void;
}

export type SerialMeta = {
	classToken: string; // class token identifier
	hash?: string; // generated by object-hash
};

/* identifier of the class */
export type SerialClassToken = string | symbol;

export interface SerializeDescriptorProperty {
	prop: string;
	type: 'Array' | 'Map' | 'Serializable';
	token: SerialClassToken;
	lazy: boolean;
}

export interface SerializeSettings {
	classToken?: SerialClassToken;
	lazy: boolean;
}
